#pragma version 10
#pragma typetrack false

// projects.trader.smart_contracts.trader_app.contract.BookContract.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0
    bytecblock 0x151f7c75 "g_status" "g_address" 0x4e414e "ACTIVE" "l_book_hash" "l_research_hash" "l_params" "g_params" "INACTIVE-STOP" "INACTIVE-SOLD"
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@13
    pushbytess 0x2325f9af 0x8789bcdb 0xabe79c1f 0x8ba817fe 0xc3bd3df5 0xfa98abdf 0xa1d81bd3 0x20bef5f7 // method "initialize(byte[],byte[],byte[])uint64", method "opt_in()uint64", method "close_out()uint64", method "update_address(account)uint64", method "update_params(byte[])uint64", method "update_status(string)uint64", method "update_local(byte[],byte[],byte[])uint64", method "delete_application()uint64"
    txna ApplicationArgs 0
    match main_initialize_route@5 main_opt_in_route@6 main_close_out_route@7 main_update_address_route@8 main_update_params_route@9 main_update_status_route@10 main_update_local_route@11 main_delete_application_route@12

main_after_if_else@15:
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    intc_1 // 0
    return

main_delete_application_route@12:
    // trader_app/contract.py:132
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_application
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_update_local_route@11:
    // trader_app/contract.py:114
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // trader_app/contract.py:114
    // @arc4.abimethod()
    callsub update_local
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_update_status_route@10:
    // trader_app/contract.py:101
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // trader_app/contract.py:101
    // @arc4.abimethod()
    callsub update_status
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_update_params_route@9:
    // trader_app/contract.py:90
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // trader_app/contract.py:90
    // @arc4.abimethod()
    callsub update_params
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_update_address_route@8:
    // trader_app/contract.py:79
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // trader_app/contract.py:79
    // @arc4.abimethod()
    callsub update_address
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_close_out_route@7:
    // trader_app/contract.py:66
    // @arc4.abimethod(allow_actions=["CloseOut"])
    txn OnCompletion
    pushint 2 // CloseOut
    ==
    assert // OnCompletion is not CloseOut
    txn ApplicationID
    assert // can only call when not creating
    callsub close_out
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_opt_in_route@6:
    // trader_app/contract.py:52
    // @arc4.abimethod(allow_actions=["OptIn"])
    txn OnCompletion
    intc_0 // OptIn
    ==
    assert // OnCompletion is not OptIn
    txn ApplicationID
    assert // can only call when not creating
    callsub opt_in
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_initialize_route@5:
    // trader_app/contract.py:40
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // trader_app/contract.py:40
    // @arc4.abimethod()
    callsub initialize
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@13:
    // trader_app/contract.py:5
    // class BookContract(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@15
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// projects.trader.smart_contracts.trader_app.contract.BookContract.initialize(user_id: bytes, book_id: bytes, parameters: bytes) -> uint64:
initialize:
    // trader_app/contract.py:40-41
    // @arc4.abimethod()
    // def initialize(self, user_id: Bytes, book_id: Bytes, parameters: Bytes) -> UInt64:
    proto 3 1
    // trader_app/contract.py:43-44
    // # Set global state
    // self.g_user_id = user_id
    pushbytes "g_user_id"
    frame_dig -3
    app_global_put
    // trader_app/contract.py:45
    // self.g_book_id = book_id
    pushbytes "g_book_id"
    frame_dig -2
    app_global_put
    // trader_app/contract.py:46
    // self.g_address = Account("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ")
    bytec_2 // "g_address"
    pushbytes base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    app_global_put
    // trader_app/contract.py:47
    // self.g_params = parameters
    bytec 8 // "g_params"
    frame_dig -1
    app_global_put
    // trader_app/contract.py:48
    // self.g_status = String("ACTIVE")
    bytec_1 // "g_status"
    bytec 4 // "ACTIVE"
    app_global_put
    // trader_app/contract.py:50
    // return UInt64(1)
    intc_0 // 1
    retsub


// projects.trader.smart_contracts.trader_app.contract.BookContract.opt_in() -> uint64:
opt_in:
    // trader_app/contract.py:55-56
    // # Validate that only the specified user can opt in
    // assert Txn.sender == self.g_address, "Only authorized user can opt in"
    txn Sender
    intc_1 // 0
    bytec_2 // "g_address"
    app_global_get_ex
    assert // check self.g_address exists
    ==
    assert // Only authorized user can opt in
    // trader_app/contract.py:57
    // assert self.g_status == String("ACTIVE"), "Contract must be active"
    intc_1 // 0
    bytec_1 // "g_status"
    app_global_get_ex
    assert // check self.g_status exists
    bytec 4 // "ACTIVE"
    ==
    assert // Contract must be active
    // trader_app/contract.py:59-60
    // # Initialize local state
    // self.l_book_hash = Bytes(b"NAN")
    bytec 5 // "l_book_hash"
    bytec_3 // 0x4e414e
    app_global_put
    // trader_app/contract.py:61
    // self.l_research_hash = Bytes(b"NAN")
    bytec 6 // "l_research_hash"
    bytec_3 // 0x4e414e
    app_global_put
    // trader_app/contract.py:62
    // self.l_params = Bytes(b"NAN")
    bytec 7 // "l_params"
    bytec_3 // 0x4e414e
    app_global_put
    // trader_app/contract.py:64
    // return UInt64(1)
    intc_0 // 1
    retsub


// projects.trader.smart_contracts.trader_app.contract.BookContract.close_out() -> uint64:
close_out:
    // trader_app/contract.py:69
    // assert Txn.sender == self.g_address, "Only authorized user can close out"
    txn Sender
    intc_1 // 0
    bytec_2 // "g_address"
    app_global_get_ex
    assert // check self.g_address exists
    ==
    assert // Only authorized user can close out
    // trader_app/contract.py:70
    // assert self.g_status == String("ACTIVE"), "Contract must be active"
    intc_1 // 0
    bytec_1 // "g_status"
    app_global_get_ex
    assert // check self.g_status exists
    bytec 4 // "ACTIVE"
    ==
    assert // Contract must be active
    // trader_app/contract.py:72-73
    // # Reset local state (though this is unnecessary as values will be deleted)
    // self.l_book_hash = Bytes(b"NAN")
    bytec 5 // "l_book_hash"
    bytec_3 // 0x4e414e
    app_global_put
    // trader_app/contract.py:74
    // self.l_research_hash = Bytes(b"NAN")
    bytec 6 // "l_research_hash"
    bytec_3 // 0x4e414e
    app_global_put
    // trader_app/contract.py:75
    // self.l_params = Bytes(b"NAN")
    bytec 7 // "l_params"
    bytec_3 // 0x4e414e
    app_global_put
    // trader_app/contract.py:77
    // return UInt64(1)
    intc_0 // 1
    retsub


// projects.trader.smart_contracts.trader_app.contract.BookContract.update_address(new_address: bytes) -> uint64:
update_address:
    // trader_app/contract.py:79-80
    // @arc4.abimethod()
    // def update_address(self, new_address: Account) -> UInt64:
    proto 1 1
    // trader_app/contract.py:82
    // assert Txn.sender == Global.creator_address, "Only creator can supdate parameters"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can supdate parameters
    // trader_app/contract.py:83
    // assert self.g_address != new_address, "New parameters must be different"
    intc_1 // 0
    bytec_2 // "g_address"
    app_global_get_ex
    assert // check self.g_address exists
    frame_dig -1
    !=
    assert // New parameters must be different
    // trader_app/contract.py:85-86
    // # Update global parameters
    // self.g_address = new_address
    bytec_2 // "g_address"
    frame_dig -1
    app_global_put
    // trader_app/contract.py:88
    // return UInt64(1)
    intc_0 // 1
    retsub


// projects.trader.smart_contracts.trader_app.contract.BookContract.update_params(new_params: bytes) -> uint64:
update_params:
    // trader_app/contract.py:90-91
    // @arc4.abimethod()
    // def update_params(self, new_params: Bytes) -> UInt64:
    proto 1 1
    // trader_app/contract.py:93
    // assert Txn.sender == Global.creator_address, "Only creator can update parameters"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can update parameters
    // trader_app/contract.py:94
    // assert self.g_params != new_params, "New parameters must be different"
    intc_1 // 0
    bytec 8 // "g_params"
    app_global_get_ex
    assert // check self.g_params exists
    frame_dig -1
    !=
    assert // New parameters must be different
    // trader_app/contract.py:96-97
    // # Update global parameters
    // self.g_params = new_params
    bytec 8 // "g_params"
    frame_dig -1
    app_global_put
    // trader_app/contract.py:99
    // return UInt64(1)
    intc_0 // 1
    retsub


// projects.trader.smart_contracts.trader_app.contract.BookContract.update_status(new_status: bytes) -> uint64:
update_status:
    // trader_app/contract.py:101-102
    // @arc4.abimethod()
    // def update_status(self, new_status: String) -> UInt64:
    proto 1 1
    // trader_app/contract.py:104
    // assert Txn.sender == Global.creator_address, "Only creator can update status"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can update status
    // trader_app/contract.py:105
    // assert (new_status == String("ACTIVE") or
    frame_dig -1
    bytec 4 // "ACTIVE"
    ==
    // trader_app/contract.py:105-107
    // assert (new_status == String("ACTIVE") or
    //         new_status == String("INACTIVE-STOP") or
    //         new_status == String("INACTIVE-SOLD")), "Status must be ACTIVE or INACTIVE-STOP or INACTIVE-SOLD"
    bnz update_status_bool_true@3
    // trader_app/contract.py:106
    // new_status == String("INACTIVE-STOP") or
    frame_dig -1
    bytec 9 // "INACTIVE-STOP"
    ==
    // trader_app/contract.py:105-107
    // assert (new_status == String("ACTIVE") or
    //         new_status == String("INACTIVE-STOP") or
    //         new_status == String("INACTIVE-SOLD")), "Status must be ACTIVE or INACTIVE-STOP or INACTIVE-SOLD"
    bnz update_status_bool_true@3
    // trader_app/contract.py:107
    // new_status == String("INACTIVE-SOLD")), "Status must be ACTIVE or INACTIVE-STOP or INACTIVE-SOLD"
    frame_dig -1
    bytec 10 // "INACTIVE-SOLD"
    ==
    // trader_app/contract.py:105-107
    // assert (new_status == String("ACTIVE") or
    //         new_status == String("INACTIVE-STOP") or
    //         new_status == String("INACTIVE-SOLD")), "Status must be ACTIVE or INACTIVE-STOP or INACTIVE-SOLD"
    bz update_status_bool_false@4

update_status_bool_true@3:
    intc_0 // 1

update_status_bool_merge@5:
    // trader_app/contract.py:105-107
    // assert (new_status == String("ACTIVE") or
    //         new_status == String("INACTIVE-STOP") or
    //         new_status == String("INACTIVE-SOLD")), "Status must be ACTIVE or INACTIVE-STOP or INACTIVE-SOLD"
    assert // Status must be ACTIVE or INACTIVE-STOP or INACTIVE-SOLD
    // trader_app/contract.py:109-110
    // # Update global status
    // self.g_status = new_status
    bytec_1 // "g_status"
    frame_dig -1
    app_global_put
    // trader_app/contract.py:112
    // return UInt64(1)
    intc_0 // 1
    retsub

update_status_bool_false@4:
    intc_1 // 0
    b update_status_bool_merge@5


// projects.trader.smart_contracts.trader_app.contract.BookContract.update_local(book_hash: bytes, research_hash: bytes, params: bytes) -> uint64:
update_local:
    // trader_app/contract.py:114-115
    // @arc4.abimethod()
    // def update_local(self, book_hash: Bytes, research_hash: Bytes, params: Bytes) -> UInt64:
    proto 3 1
    // trader_app/contract.py:117
    // assert Txn.sender == self.g_address, "Only authorized user can update local state"
    txn Sender
    intc_1 // 0
    bytec_2 // "g_address"
    app_global_get_ex
    assert // check self.g_address exists
    ==
    assert // Only authorized user can update local state
    // trader_app/contract.py:118
    // assert self.g_status == String("ACTIVE"), "Contract must be active"
    intc_1 // 0
    bytec_1 // "g_status"
    app_global_get_ex
    assert // check self.g_status exists
    bytec 4 // "ACTIVE"
    ==
    assert // Contract must be active
    // trader_app/contract.py:120-121
    // # Ensure at least one value is changing
    // assert (self.l_book_hash != book_hash or
    intc_1 // 0
    bytec 5 // "l_book_hash"
    app_global_get_ex
    assert // check self.l_book_hash exists
    frame_dig -3
    !=
    // trader_app/contract.py:120-123
    // # Ensure at least one value is changing
    // assert (self.l_book_hash != book_hash or
    //         self.l_research_hash != research_hash or
    //         self.l_params != params), "At least one parameter must change"
    bnz update_local_bool_true@3
    // trader_app/contract.py:122
    // self.l_research_hash != research_hash or
    intc_1 // 0
    bytec 6 // "l_research_hash"
    app_global_get_ex
    assert // check self.l_research_hash exists
    frame_dig -2
    !=
    // trader_app/contract.py:120-123
    // # Ensure at least one value is changing
    // assert (self.l_book_hash != book_hash or
    //         self.l_research_hash != research_hash or
    //         self.l_params != params), "At least one parameter must change"
    bnz update_local_bool_true@3
    // trader_app/contract.py:123
    // self.l_params != params), "At least one parameter must change"
    intc_1 // 0
    bytec 7 // "l_params"
    app_global_get_ex
    assert // check self.l_params exists
    frame_dig -1
    !=
    // trader_app/contract.py:120-123
    // # Ensure at least one value is changing
    // assert (self.l_book_hash != book_hash or
    //         self.l_research_hash != research_hash or
    //         self.l_params != params), "At least one parameter must change"
    bz update_local_bool_false@4

update_local_bool_true@3:
    intc_0 // 1

update_local_bool_merge@5:
    // trader_app/contract.py:120-123
    // # Ensure at least one value is changing
    // assert (self.l_book_hash != book_hash or
    //         self.l_research_hash != research_hash or
    //         self.l_params != params), "At least one parameter must change"
    assert // At least one parameter must change
    // trader_app/contract.py:125-126
    // # Update local state
    // self.l_book_hash = book_hash
    bytec 5 // "l_book_hash"
    frame_dig -3
    app_global_put
    // trader_app/contract.py:127
    // self.l_research_hash = research_hash
    bytec 6 // "l_research_hash"
    frame_dig -2
    app_global_put
    // trader_app/contract.py:128
    // self.l_params = params
    bytec 7 // "l_params"
    frame_dig -1
    app_global_put
    // trader_app/contract.py:130
    // return UInt64(1)
    intc_0 // 1
    retsub

update_local_bool_false@4:
    intc_1 // 0
    b update_local_bool_merge@5


// projects.trader.smart_contracts.trader_app.contract.BookContract.delete_application() -> uint64:
delete_application:
    // trader_app/contract.py:135
    // assert Txn.sender == Global.creator_address, "Only creator can delete application"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can delete application
    // trader_app/contract.py:136
    // assert (self.g_status == String("INACTIVE-STOP") or
    intc_1 // 0
    bytec_1 // "g_status"
    app_global_get_ex
    assert // check self.g_status exists
    bytec 9 // "INACTIVE-STOP"
    ==
    // trader_app/contract.py:136-137
    // assert (self.g_status == String("INACTIVE-STOP") or
    //         self.g_status == String("INACTIVE-SOLD")), "Contract must be inactive to delete"
    bnz delete_application_bool_true@2
    // trader_app/contract.py:137
    // self.g_status == String("INACTIVE-SOLD")), "Contract must be inactive to delete"
    intc_1 // 0
    bytec_1 // "g_status"
    app_global_get_ex
    assert // check self.g_status exists
    bytec 10 // "INACTIVE-SOLD"
    ==
    // trader_app/contract.py:136-137
    // assert (self.g_status == String("INACTIVE-STOP") or
    //         self.g_status == String("INACTIVE-SOLD")), "Contract must be inactive to delete"
    bz delete_application_bool_false@3

delete_application_bool_true@2:
    intc_0 // 1

delete_application_bool_merge@4:
    // trader_app/contract.py:136-137
    // assert (self.g_status == String("INACTIVE-STOP") or
    //         self.g_status == String("INACTIVE-SOLD")), "Contract must be inactive to delete"
    assert // Contract must be inactive to delete
    // trader_app/contract.py:139
    // return UInt64(1)
    intc_0 // 1
    retsub

delete_application_bool_false@3:
    intc_1 // 0
    b delete_application_bool_merge@4
